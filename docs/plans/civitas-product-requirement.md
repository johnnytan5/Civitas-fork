
ðŸ“œ Civitas: Professional Product Requirement Plan
1. Frontend Module: "The Intent-Centric Interface"
Core Tech: Next.js 14+ (App Router), TailwindCSS, Shadcn/UI, Framer Motion (Animations), React Flow (Diagrams).
Key Functional Requirements:
Onboarding: Integration with Base Wallet SDK. Must support "Smart Wallet" features (Passkeys, 1-click creation).
The Command Bar: A natural language input field.
State 1 (Idle): Simple prompt box.
State 2 (Processing): Loading state with "Thinking" text generated by the LLM.
State 3 (Analysis): Display the Magic Table. A floating UI component where users see extracted Payers/Receivers.
Interaction: Users can inline-edit addresses, amounts, and roles.
The Visualization Engine: Using React Flow, render a directed graph showing:
Nodes: User Wallets, Civitas Smart Vault, Recipient Wallet.
Edges: USDC amount flow labels and "Trigger" conditions (e.g., "On Feb 1st" or "2/3 Signatures").
Contract Interaction Dashboard: Once deployed, the UI must switch to a "Live Agreement" view.
Funding Bar: Real-time visualization of $AmountDeposited / AmountGoal$.
Events Log: A list of on-chain activities (Deposit, Yield Accrued, Withdrawal) filtered via Supabase Realtime or BaseScan API.

2. Backend Module: "The Logic & Data Orchestrator"
Core Tech: Express.js (Node.js), Supabase (PostgreSQL + Auth + Realtime), Viem.
Key Functional Requirements:
API Layer (Express):
POST /analyze-intent: Routes user prompts to the AI Module.
POST /deploy-contract: Receives validated parameters and triggers the on-chain deployment via a server-side wallet or relays it back to the client.
GET /agreement/:id: Fetches agreement state (combining DB data and on-chain state).
Database Schema (Supabase):
users: Wallet address, ENS name, preferences (saved in metadata).
agreements: ID, contract_address, creator_address, type (Rent/Split), status (Proposed/Active/Settled).
participants: Mapping users to agreements with their specific share and has_signed status.
On-Chain Sync:
Use Supabase Edge Functions or a background worker to listen for events on Base. When a Deposit event hits the smart contract, the database must update the "Funding Progress" immediately via Postgres Changes (Realtime).

3. AI LLM Module: "The Deterministic Translator"
Core Tech: LangChain, OpenAI/Gemini (via Antigravity), Zod (Schema Validation).
Key Functional Requirements:
Intent Extraction (The Parser):
Utilize a System Prompt that enforces a strict JSON output.
Input: "I want to split 1200 USDC rent with @bob.eth and @alice.eth. Release on the 1st."
Output: { "type": "RENT_POOL", "total": 1200, "recipients": ["landlord.eth"], "participants": [{"name": "bob.eth", "share": 400}, ...], "trigger": "DATE_LOCKED" }
Validation & Guardrails (LangChain):
Implement an Output Fixer. If the LLM misses an address, the AI must flag it: "I found @bob.eth but couldn't resolve the address. Please provide it."
Mathematical Consistency: Ensure $\sum shares == total\_amount$.
Contract Template Mapping:
A logic layer that maps the type (e.g., "RENT_POOL") to the specific Solidity Bytecode ID and prepares the constructor arguments for the Backend.

ðŸ—ï¸ Module 4: Web3 & Smart Settlement Infrastructure
4.1 The Template Architecture
We will use a Template-Factory Pattern. Each user intent triggers the CivitasFactory to deploy one of these three specialized clones.
Template 1: The "Civitas" Multi-Tenant Rent Vault
Target: Roommates/Shared Living.
Logic:
deposit(amount): Maps user address to their specific debt in tenantBalances.
autoStake(): Automatically triggers IAToken(aUSDC).supply() on Aave V3 whenever the contract balance exceeds a threshold.
approveRelease(): A mapping hasApproved[address] tracking $N-1$ signatures from payers.
withdrawToLandlord(): Once $ApprovalCount \ge Participants - 1$, the total principal is sent to the landlord.
The Interest Logic: Interest (accrued aUSDC) remains in the contract vault after the principal is paid. A separate withdrawInterest() function allows the "Group Lead" to withdraw and automatically send funds back to each payerâ€™s wallet
Template 2: The "Group Buy" Escrow (Lead-Majority Model)
Target: Shared purchases or service payments.
Logic:
fundingGoal: The target USDC amount. If not met by expiryDate, refund() is enabled.
confirmDelivery(): trigger:
Majority Vote: a $>50\%$ vote from participants triggers release.
timelockRefund(): If confirmDelivery isn't called within $X$ days post-goal, participants can pull their specific deposit back.
Template 3: The "Stable-Allowance" Treasury (Counter-Based)
Target: Remittances and controlled spending (e.g., Parent to Child).
Logic:
allowancePerIncrement: A fixed amount (e.g., 50 USDC).
approvalCounter: An internal uint256. Only the Owner (Parent) can call incrementCounter().
claimedCount: Tracks how many times the recipient has withdrawn.
claim():
Requirement: claimedCount < approvalCounter.
Action: Transfers allowancePerIncrement, then claimedCount++.
Edge Case: If the parent wants to "fast-track" money, they can call incrementCounter() multiple times at once, allowing the child to claim multiple "packets" of USDC.

4.2 ENS Track Optimization (The "Inspector" Data)
To win the ENS prize, your Factory contract will perform Cross-Contract Metadata Storage:
Subname Creation: The Factory will create a subname for every agreement (e.g., agreement-88.civitas.eth).
Text Record Injection: During deployment, the Factory calls the ENS Public Resolver to set:
com.civitas.type: (e.g., "RentVault")
com.civitas.logic: A string summary of the rules (e.g., "2/3 Approval to Landlord")
com.civitas.vault: The deployed contract address.
Why this is cool: This makes the agreement "Protocol-Readable." Any other app could read these ENS records and understand the user's financial commitments.

4.3 Base L2 Native Features
ERC-20 Permit: All templates will support permit() so users can sign a message to "Approve" USDC instead of making two transactions.
Base Paymaster (Optional): We will use Coinbase OnchainKit to sponsor the deployment gas, making the app feel "Web2-smooth" for non-crypto users.
Standard Tokens: Primarily focused on USDC (the native stablecoin of Base).

4.4 Data Schema for AI Orchestrator
When the AI Agent parses intent, it must output a JSON object that matches these Solidity structs:
JSON
{
  "templateId": 1, 
  "params": {
    "participants": ["0xAlice...", "0xBob..."],
    "recipient": "0xLandlord...",
    "amountPerPerson": 500000000, 
    "approvalThreshold": 2,
    "ensLabel": "room-402-rent"
  }
}

ðŸ› ï¸ Execution Toolset for your Agents:
Foundry: For testing the Aave V3 integration (using Mainnet/Base Forking).
Ethers: deploy smart contract dynamically
Viem: For the Backend/Frontend to encode the function data for the CivitasFactory.
OpenZeppelin: For Clones.sol (Minimal Proxy) and Ownable.sol (Access Control).
